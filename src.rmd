---
layout: default
title: Compiled code
output: bookdown::html_chapter
---

# Compiled code {#src}

It's often useful to include compiled code in an R package. Compiled code, whether it's C, C++ or Fortran, is a powerful complement to R code. R code is high-level and expressive, but that expressivity comes at a cost: speed. Low-level languages like C and C++ often require more typing to solve a problem, they can be multiple orders of magnitude faster than R. 

Teaching you how to write C and C++ code is beyond the scope of the book. If you don't already know a compiled language, I'd recommmend learing C++ and the Rcpp package. The Rcpp package makes it incredibly easy to connect C++ to R, and RStudio has a lot of built in tools to facilitate the process. If you'd like to learn how to write Rcpp code, I'd recommend starting with ["High performance functions with Rcpp"](http://adv-r.had.co.nz/Rcpp.html) a freely available book chapter from [Advanced R](http://amzn.com/1466586966?tag=devtools-20). Once you've done that, check out the [Rcpp book](http://www.rcpp.org/book) and the other resources listed in [learning more](http://adv-r.had.co.nz/Rcpp.html#rcpp-more).

The rest of this chapter will assume you know how to write some C or C++ code. If you don't, feel free to skip this chapter; come back to it later when you need to solve a performance problem.

## C++

The easiesy way to use a high-performance langauge from R is to use C++ with Rcpp. To get started, run:

```{r, eval = FALSE}
devtools::use_rcpp()
```

This will:

* Create a `src/` directory where you'll put your `.cpp` files.

* Add `Rcpp` to the `LinkingTo` and `Imports` fields in the `DESCRIPTION`.

* Set up a `.gitignore` file to make sure you don't accidentally check in
  any compiled files (if you're using [git](#git)).

* Tells you about two roxygen tags you need to add to your package:

    ```{r}
    #' @useDynLib your-package-name
    #' @importFrom Rcpp sourceCpp
    ```

Once you've done this, the basic workflow is simple:

1.  Create a new C++ file:

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/new-cpp.png", dpi = 220)
    ```

    The default template looks like this:
    
    ```cpp
    #include <Rcpp.h>
    using namespace Rcpp;
    
    // Below is a simple example of exporting a C++ function to R. You can
    // source this function into an R session using the Rcpp::sourceCpp 
    // function (or via the Source button on the editor toolbar)
    
    // For more on using Rcpp click the Help button on the editor toolbar
    
    // [[Rcpp::export]]
    int timesTwo(int x) {
       return x * 2;
    }
    ```
    
    It includes a basic function and some instructions to get started.

1.  Press Cmd + Shift + L (or Cmd + Shift + B).

1.  Run `timesTwo(10)` to confirm that the code works.

If you have any compile errors, they will appear in a special pane at the top-left.

## C

If you're writing new compiled code, it's almost always better to use Rcpp. There are three reasons to understand R's C API:

* You're working with a package written before Rcpp that uses the C API.
* You're binding to another C library.
* You want to eke out every last drop of performance.

There are two ways to call C functions from R: `.C()` and `.Call()`. `.C()` is an older interface and should not be used for new code. You'll need to read about it yourself in [Interface .C and .Fortran functions](http://cran.r-project.org/doc/manuals/R-exts.html#Interface-functions-_002eC-and-_002eFortran) in R-exts. All modern code should use `.Call()`.

There are two sides to accessing a C function in R. First you write the C function. It goes in `.c` file in `src/`. Every C file that interfaces with R must contain two header files:

```c
#include <R.h>
#include <Rinternals.h>
```

(Including `<Rinternals.h>` seems like bad form, but it doesn't actually give you access to the "internal" internal API unless you set some additional flags. The default just gives you the "external" internal API which both safe and necessary for the majority of C code. Yes, this is confusing.)

These headers allow you to access R's C API. Unfortunately this API is not well documented. I'd recommend starting with my notes at [R's C interface](http://adv-r.had.co.nz/C-interface.html). After that you'll need to read [R extensions](http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html) and a lot of [R's source code](https://github.com/wch/r-source) to figure out what the different functions do.

The absolute minimum that you need to know is that C functions that talk to R code must use the `SEXP` type for both inputs and outputs. At the heart of every C function is a set of conversions between R objects and C objects. For example to convert length one vectors back and forth between C scalars, you use the following functions:

R type      | C type      | R -> C            |  C -> R 
------------|-------------|-------------------|-------------------
integer     | int         | `asInteger(x)`    | `ScalarInteger(x)`
numeric     | double      | `asReal(x)`       | `ScalarReal(x)`
logical     | int         | `asLogical(x)`    | `ScalarLogical(x)`
chararacter | const char* | `CHAR(asChar(x))` | `mkString(x)`

A simple C function to add two numbers together would look like this:

```c
#include <R.h>
#include <Rinternals.h>

SEXP add_(SEXP x_, SEXP y_) {
  double x = asReal(x_);
  double y = asReal(y_);
  
  double sum = x + y;
  
  return ScalarReal(sum);
}
```

(Working with vectors is considerably more complicated.)

As well as this C function, you also need an R wrapper:

```{r}
#' @useDynLib mypackage add_
add <- function(x, y) .Call(add_, x, y)
```

The `@useDynLib` directive is important - it creates a line in the NAMESPACE that looks like this:

```
useDynLib(mypackage, add_)
```

This will create an object called `add_` in the package environment. This object represents a pointer to the C function in memory.

```{r, eval = FALSE}
add
#> $name
#> [1] "add_"
#> 
#> $address
#> <pointer: 0x107be3f40>
#> $package
#> NULL
#> 
#> attr(,"class")
#> [1] "NativeSymbolInfo"
```

`.Call()` takes pointer to a C function and calls it. It does not checking of the arguments (either number of type), so you'll either have to do that checking in your wrapper function or in your C function, or live with R crashing any time you accidentally supply the wrong type of argument.

Whenever you use C or C++ code in your package, you should be a good citizen and clean up after yourself if your package is unloaded. This basically means that you should have a `.onUnload()` function that unloads the DLL that `useDynLib` dynmically loaded for you.

```{r}
.onUnload <- function (libpath) {
  library.dynam.unload("mypackage", libpath)
}
```

### Function registration

If you want to make your C functions available to other packages (without going through the R wrapper), you need to "register" the functions. To do this you create an array of functions to register (containing the name, a function pointer, and the number of arguments) and then call `R_registerRoutines()` in the initialisation function. For example, to register the `add_` function defined above, you include C code like:

```c
#include "add.h"
#include <R_ext/Rdynload.h>

R_CallMethodDef callMethods[]  = {
  {"add_", (DL_FUNC) &add_, 2},
  {NULL,   NULL,            0}
};

void R_init_mypackage(DllInfo *info) {
  R_registerRoutines(info, NULL, callMethods, NULL, NULL);
}
```

Note the use of `#include add.h`: you'll also need to make a header file that defines the external interface to your C files.

Typically this code is put in a file called `init.c`. The other arguments to `R_registerRoutines` are used for more esoteric interfaces: `.C`, `.Fortran` and `.External`. For more details, see [Registering native extensions](http://cran.r-project.org/doc/manuals/R-exts.html#Registering-native-routines) in R-exts.

If you choose to use registration, you don't need a `@useDynLib` directive for each C function. Instead you can make all symbols available with a single tag: `@useDynLib mypackage, .registration = TRUE`.

## Makefiles

Makefiles beyond the scope of this book, but see <http://kbroman.org/minimal_make/> to get started with a reproducible research example. Generally you should avoid using a custom `Makefile` in an R package. Instead use `Makevars`, which allows you to set important compiler variables:

* PKG_CFLAGS: C flags
* PKG_CXXFLAGS: C++ flags
* PKG_CPPFLAGS: Pre-processor flags (not C++ flags!), like include directories.

## Other languages

* __Fortran__: It's possible to call Fortran 77 subroutines directly with 
  `.Fortran()`. See the documentation for details. Note that in one package you
  can mingle C and C++, and C and Fortran, but not C++ and Fortran.

* __Java__: The [rJava](https://github.com/s-u/rJava) package makes it 
  possible to call Java code from within R. Note that unlike for C and C++,
  passing an R object to a java call must make a copy, which has serious
  performance implications.

## Licensing

If you package code includes code written by someone else you need to:

* Ensure that the package license is compatible with the included code. License
  compatibility is a complex issue, and for non-standard cases you will need
  to consult a lawyer.
  
  The simplest situation is to use the same license for your code and the 
  included code. If you don't want to use the same license, you're best sticking
  with common cases where the interactions are well known. For example, 
  [Various Licenses and Comments about Them](https://www.gnu.org/licenses/license-list.html)
  describes what licenses are compatible with GPL licensed software. In this
  case your description should contain `License: <main license> + FILE license`
  where the `license` file describes the licenses of the individual
  components.

## CRAN issues

If you're submitting a package containing compiled code, the main thing to be aware of is that you could must work on all major platforms (linux, windows and mac). It is sometimes possible to opt-out, of one platform, if you can providing a compelling reason during package submission (e.g. you're binding to OS specific functionality).

The other thing to be aware of is that sometimes (depending on which CRAN maintainer handles your submission), your package may also need to work on Solaris. This is typically considerably more complicated and there are few resources available to help you.

Sometimes CRAN will require you to list all authors and copyright holders of included code in the DESCRIPTION. This rule is inconsistently applied, but if it's applied to you, it's just best to bite the bullet and make the change rather than trying to argue about it.

