---
title: Releasing a package
layout: default
output: bookdown::html_chapter
---

# Releasing a package {#release}

If you want your package to have significant traction in the R community, you need to submit it to CRAN. Submitting to CRAN is a lot more work than just providing a version on github, but the vast majority of R users do not install packages from github. The CRAN submission process can be frustrating, but it's worthwhile, and this chapter will make it as painless as possible.

To get your package ready to release, follow these steps:

1. Pick a version number.
1. Run and document `R CMD check`.
1. Check that you're aligned with CRAN polices.
1. Update `README.md` and `NEWS.md`.
1. Submit the package to CRAN.
1. Prepare for the next version.
1. Publicise the new version.

## Version number {#release-version}

If you've been following the advice in [versioning](#version), the version number of your in-development package will have four components, `major.minor.patch.dev` (where `dev` is at least 9000). Released packages don't have a `dev` component, so now you need to drop that and pick a version number based on the changes you've made. For example, if the current version is `0.8.1.9000` will the next version be `0.8.2`, `0.9.0` or `1.0.0`? Use this advice to decide:
  
  * Increment `patch`, e.g. `0.8.2` for a __patch__: you've fixed
    bugs without adding significant new features. I'll often do a patch release 
    if after release I discover a show-stopping bug that needs to be fixed 
    ASAP.
  
  * Increment `minor`, e.g. `0.9.0`, for a __minor release__. A minor 
    release can include bug fixes, new features and backward compatible changes. 
    This is the most common type of release. It's perfectly fine to have so 
    many minor releases that you need to use two digits, e.g. `1.17.0`.
  
  * Increment `major`, e.g. `1.0.0`, for a __major release__. This is
    best reserved for backward incompatible changes that are likely to affect 
    many users. Going from `0.b.c` to `1.0.0` typically indicates that your 
    package is feature complete with a stable API.
    
    In practice, backward compatibility is not discrete, but continuous. For 
    example, if you make an API-incompatible change to a rarely-used part of 
    your code, it may not deserve a major number change. If you fix a bug that 
    many people are depending on, it will feel like an API breaking change.
    Use your best judgement.
    
### Backward compatibility

The big different between major and minor versions is whether or not the code is backward compatible.  This difference tends to be a bit academic in the R community because the way most people update packages is by running `update.packages()`. `update.packages()` always updates to the latest version of the package, even if the major version has changed, potentially breaking code. While more R users are becoming familiar with tools like [packrat](http://rstudio.github.io/packrat/) that capture dependency versions on a per-project basis, you still need to be a little cautious when making big backward incompatible changes, regardless of what you do with the version number. 

The importance of backward compatability is directly proportional to the number of people using your package because you are trading your time for your users time. The harder you strive to be backward compatible, the harder it is to develop new features or fix old mistakes. Backward compatible code also tends to be harder to read because it requires multiple paths to support functionality from previous versions. Be concerned about backward compatibility, but don't let it paralyse you. 

Generally, you should strive to backward incompatible changes gradually. You need an interim version between the where are you now and the ideal implementation that provides advice about what's changing.  Depending on what you're changing, use one of the following techniques to let your users know what's happening:

  * Don't immediately remove a function. First deprecate it. For example, imagine
    your package is version `0.5.0` and you want to remove `fun()`. In 
    version, `0.6.0`, you'd use `.Deprecated()` to display a warning message
    whenever someone uses the function:
  
    ```{r}
    # 0.1.0
    fun <- function(x, y, z) {
      .Deprecated("sum")
      x + y + z
    }
    ```
    
    Then you'd remove the function once you got to `0.7.0` (or if you were
    being very strict, once you got to `1.0.0` since it's a backward 
    incompatible change).

  * Similarly, if you're removing a function argument, first warn about it:
  
    ```{r}
    bar <- function(x, y, z) {
      if (!missing(y)) {
        warning("argument y is deprecated; please use z instead.", 
          call. = FALSE)
        z <- y
      }
    }
    ```

  * If you're deprecating a lot of code, it can be useful to add a helper 
    function. For example, ggplot2 has `gg_dep` which automatically
    displays a message, warning or error, depending on how much the version
    number has changed.
    
    ```{r}
    gg_dep <- function(version, msg) {
      v <- as.package_version(version)
      cv <- packageVersion("ggplot2")
    
      # If current major number is greater than last-good major number, or if
      #  current minor number is more than 1 greater than last-good minor number,
      #  give error.
      if (cv[[1,1]] > v[[1,1]]  ||  cv[[1,2]] > v[[1,2]] + 1) {
        stop(msg, " (Defunct; last used in version ", version, ")",
          call. = FALSE)
    
      # If minor number differs by one, give warning
      } else if (cv[[1,2]] > v[[1,2]]) {
        warning(msg, " (Deprecated; last used in version ", version, ")",
          call. = FALSE)
    
      # If only subminor number is greater, give message
      } else if (cv[[1,3]] > v[[1,3]]) {
        message(msg, " (Deprecated; last used in version ", version, ")")
      }
    
      invisible()
    }
    ```

  * Significant changes to an existing function will require planning and may 
    require gradual changes over multiple versions. Try and develop a sequence
    of transformations where each change can be accompanied by an informative
    error message.

  * If you want to use functionality in a new version of another package,
    don't make it a hard install-time dependency in the `DESCRIPTION` (because
    forcing your users to upgrade that package might break other code). Instead
    check for the version at run-time:
    
    ```{r}
    if (packageVersion("ggplot2") < "1.0.0") {
      stop("ggplot2 >= 1.0.0 needed for this function.", call. = FALSE)
    }
    ```

## The check process {#release-check}

You've already learned how to use `R CMD check` and why it's important in [automated checking](#check). Compared to running `R CMD check` locally, there are two important differences when running it for CRAN submission:

* You __MUST__ eliminate all `ERROR`s and `WARNING`s. You __should__ eliminate 
  as many `NOTE`s as possible. Each `NOTE` requires human oversight, which is a
  precious commodity. If there are notes that you do not believe are important, 
  it is almost always easier to fix them (even if the fix is a bit of a hack) 
  than to persuade CRAN that they're ok. 
  
* You need to document your process and clearly communicate the results to CRAN.
  Write your comments in way that's easy to scan, and easy to match up with
  `R CMD check`. Provide the CRAN maintainers with everything they need in 
  one place, even if it means repeating yourself.

CRAN is staffed by volunteers and they all have other full-time jobs. In a typical week, CRAN recieves around 130 packages, and there are only three volunteers to process them all. The less work you make for them the more likely you are to have a pleasant submission experience.

I recommend that you use `cran-comments.md` file to describe your checking process and, if you have any, why `NOTE`s from `R CMD check` are ok. `cran-comments.md` should be checked into git (so you can track it over time), and listed in `.Rbuildignore` (so it's not included in the package). As the extension suggests, I recommend using markdown because it gives a standard way of laying out plain text. However, the contents will never be rendered to another format, so you don't need to worry about sticking to it too closely.

Here's my `cran-comments.md` from a recent version of devtools:

```
The following notes were generated across my local OS X install, ubuntu running on travis-ci and win builder. Response to NOTEs across three platforms below.

* checking dependencies in R code ... NOTE
  Namespace in Imports field not imported from: ‘memoise’
  All declared Imports should be used.
  
  memoise is a build-time dependency.

* checking R code for possible problems ... NOTE
  Found the following calls to attach():
    File 'devtools/R/package-env.r':
      attach(NULL, name = pkg_env_name(pkg))
    File 'devtools/R/shims.r':
      attach(e, name = "devtools_shims", warn.conflicts = FALSE)

  These are needed because devtools simulates package loading, and hence
  needs to attach environments to the search path.
```

I always organise it in the same way:

* Start by listing how you have checked the package. What platforms and 
  what version of R did you use? In an ideal world you will have 
  checked with it R-devel and on at least two platforms. See 
  [R-devel](#release-r-devel) and [Cross platform](#release-cross-platform)
  for more details.

* If there are any `NOTE`s, copy and paste the message from `R CMD check` and 
  include a brief description of why you believe the NOTE is a false positive. 
  
* If there are CRAN packages that use your package, you need to run 
  `R CMD check` on all those packages, and summarise the results. See
  [reverse dependency checks](#release-deps) for more details.

### R-devel {#release-r-devel}

It's a good idea to check your package with the latest version of R-devel, which is what CRAN uses. The checks are constantly changing and you often need to run the latest checks locally. The easiest way to get R-devel is to: 

* Mac: install from <http://r.research.att.com>.

* Windows: install from <http://cran.r-project.org/bin/windows/base/rdevel.html>

* Linux: either build it from source, or better, learn about docker containers
  and run the R-devel container from <https://github.com/rocker-org/rocker>.

### Cross-platform checking {#release-cross-platform}

As well as running R-devel, CRAN runs R on multiple platforms: Windows, OS X, Linux and Solaris. Generally, you don't need to run `R CMD check` yourself on every one of these platforms, but it's a really good idea to do it on at least two to increase your chances of spotting code that relies on the idiosyncracries of a specific platform.

To run checks on Windows, use `devtools::build_win()`. This builds your package and submits it to the R-devel and R-release CRAN win-builders. 10-20 minutes after submission, you'll recieve an email telling you the check results. 

To run checks on Linux, I recommend using travis, as described in [continuous integration with Travis](#travis).

Debugging code that works on your computer but fails elsewhere is painful. I recommend either installing a virtualisation tool so that you can run another operating system locally, or find a friend to help you figure out the problem.

### Checking dependencies {#release-deps}

If you're releasing a new version of an existing package, it's your responsibility to ensure downstream dependencies (i.e. all packages that list your package in the `Depends`, `Imports`, `Suggests` or `LinkingTo` fields) continue to work. To help you do this, devtools provides `devtools::revdep_check()`. This:

1. Sets up a temporary library so it doesn't clobber any existing packages you
   have installed.
   
1. Installs all of the dependencies of the downstream dependencies.

1. Runs `R CMD check` on each package.

1. Summarises the results in a single file.

If any packages fail `R CMD check`, you should give package authors at least two weeks to fix the problem before you submit your package to CRAN (you can easily get all maintainer email addresses with `revdep_maintainers()`).  After the two weeks is up, re-run the checks, and list any remaining failures in `cran-comments.md`. Each package should be accompanied by a  brief explanation: either tell CRAN that it's a false positive in `R CMD check` (e.g. you couldn't install a dependency locally) or a legitimate change in the API (which the maintainer hasn't fixed yet). 

Inform CRAN of your release process: "I advised all downstream packages maintainers of these problems two weeks ago". Here's an example from a recent release of httr:

Here's an example from a recent release of dplyr:

```
Important reverse dependency check notes (summary at https://github.com/wch/checkresults/blob/master/dplyr/r-release/00check-summary.txt);

* COPASutils, freqweights, qdap, simPH: fail for various reasons. All package 
  authors were informed of the upcoming release and shown R CMD check issues 
  over a week ago.

* ecoengine: same problem as always on our test machine.

* ggvis: You'll be recieving a submission that fixes these issues very shortly
  from Winston.

* repra, rPref: uses a deprecated function.
```

## CRAN policies

There are a number of [CRAN policies](http://cran.r-project.org/web/packages/policies.html) that can not be checked automatically. You need to be familiar with this document.

I've summarised the most common problems below:

* It is vital that maintainer email address is stable. This is the only way
  that CRAN has to contact you, and they will remove your package from CRAN
  if there are problems and they can't get in touch with. Make sure it's 
  something that's likely to be around for a while, and that it's not heavily 
  filtered.

* You must have clearly identified the copyright holders in `DESCRIPTION`:
  if you have included external source code, you must ensure that the license
  is compatible. See [license](#license) and [`src/` licensing](#src-licensing)
  for more details.

* You must "make all reasonable efforts" to get your package working across
  multiple platforms, and packages that don't work on at least two will
  not normally be considered.

* Do not make external changes without explicit user permission. Don't write to 
  the file system, change options, install packages, quit R, send information 
  over the internet, open external software, etc.
  
* Do not submit updates too frequently. The policy suggests a new version
  once every 1-2 months at most.

I recommending following the [CRAN Policy Watch](https://twitter.com/CRANPolicyWatch) twitter account which tweets whenever the policies change. You can also look at the github repository that powers it: <https://github.com/eddelbuettel/crp/commits/master/texi>.

## Important files {#important-files}

Every package should contain a `README.md` that describes what the package does, and a `NEWS.md` that describes what's changed since the previous version. I recommend using markdown for these files, because it's useful for them to be readable in plain text (e.g. in emails) and in html (e.g. on github, in blog posts). I recommend using Github flavoured markdown, [gfm](#gfm), for these files.

### README.md {#readme}

The goal of the `README.md` is to answer the following questions:

* Why should I use it?
* How do I use it?
* How do I get it?

On github, the `README.md` will be rendered to html and displayed on the repo home page. 

I normally structure my `README` as follows:

1.  A paragraph that describes the high-level purpose of the package.
1.  An example showing how to use the package to solve a simple problem.
1.  An overview that describes the main components of the package. For more
    complex packages, this will point to vignettes for more details.
1.  Installation instructions, giving code that can be copied and pasted in R.

### README.Rmd {#readme-rmd}

If you include an example in your `README` (a good idea!) you may want to generate it with Rmarkdown. The easiest way to get started is to use `devtools::use_readme_rmd()`. This creates a template `README.Rmd` and adds it to `.Rbuildignore`. The template looks like:
    
```{r, echo = FALSE, comment = ""}
cat(devtools:::render_template("README.Rmd"), "\n")
```

This:

* Uses Github's markdown format for output (it has a few less features than the 
  pandoc standard).

* Includes a comment in `README.md` to remind you to edit `README.Rmd`, not
  `README.md`.

* Sets up my recommend knitr options, including saving an images to 
  `README-chunkname.png` (which is automatically `.Rbuildignore`d.)

You'll need to remember to re-knit `README.Rmd` each time you modify it. If you use git, `use_readme_rmd()` automatically adds the following "pre-commit" hook:

```bash
#!/bin/bash
if [[ README.Rmd -nt README.md ]]; then
  echo "README.md is out of date; please re-knit README.Rmd"
  exit 1
fi 
```

This prevents `git commit` from succeeding unless `README.md` is more recent than `README.Rmd`. If you get a false positive, you can ignore the check with `git commit --no-verify`.  Note that git commit hooks are not stored in the repository, so every time you check out the repo, you'll need to run `devtools::use_readme_rmd()` to set it up again.

### NEWS.md {#news}

The `README.md` is aimed at a potential new user of your package. The `NEWS.md` is aimed at existing users: it should list all changes in each last release of the package. There are a number formats you can use for package news, but I recommend `NEWS.md`. It's not supported by CRAN (so you'll need to run `devtools::add_build_ignore("NEWS.md")`), but it's well supported by github and is easy to re-purpose to other formats.

Organise your `NEWS.md` as follows:

* Use a level-one heading for each version: e.g. `# mypage 1.0`. The most
  recent version should go at the top.

* Each change should be included in a bulleted list. If you have a lot of 
  changes you might want to break them up using subheadings, `## Major changes`,
  `## Bug fixes` etc. I usually stick with a simple list until just before
  releasing the package when I'll reorgnise into sections, if needed.
  It's hard to know in advance exactly how many 

* If an item is related to an issue in github, include the issue number in
  parentheses, e.g. `(#10)`. If an item is related to a pull request, include 
  the pull request number and the author, e.g. `(#101, @hadley)`. Doing
  this makes it easy to navigate to the relevant issues on github.

The main challenge with `NEWS.md` is getting into the habit of noting each change as it happens. 

## Release

You're now ready to submit your package to CRAN. The easiest way to do this is to run `devtools::release()`. This:

* Builds the package and runs `R CMD check` one last time.

* Asks you a number of yes/no questions to verify that your followed the
  most common best practices.
  
* You can add your own questions to the check process by including an
  unexpected `release_questions()` function in your package. This should
  return a character vector of questions to ask. For example, httr has:
  
    ```{r}
    release_questions <- function() {
      c(
        "Have you run all the OAuth demos?",
        "Is inst/cacert.pem up to date?"
      )
    }
    ```
    
    This is useful for reminding you to do any manual tasks that 
    can't otherwise be automated.
  
* Submits the package to the 
  [CRAN submission form](http://cran.r-project.org/submit.html) along with
  the comments in `cran-comments.md`.

Within the next few minutes, you'll recieve a email notifying you of the submission and asking you to approve it (this confirms that the maintainer address is correct). Next the CRAN maintainers will run their checks and get back to you with the results. This normally takes around 24 hours, but occassionally can take up to 5 days.

### On failure



Failures are frustrating, and the response you receive may be curt or downright insulting. Unfortunately no recourse is available, so you just have to develop a thick skin. You're not alone: even members of R-core have to go through the same gruelling process, and CRAN is no friendlier to them. Try not to get upset by the feedback. Ignore any ad hominen attacks, and simply respond to the technical content.  Arguing with CRAN about the merits of a check is usually fruitless and best avoided.

On failure, make the suggested changes, update `cran-comments.md` describing what you did and why, and re-run `release()`. CRAN prefers you to not respond to their emails unless discussion is required.

Devtools comes with a small guarantee to make life a little more pleasant: If a CRAN maintainer is annoyed with you because devtools did something wrong, I will send you a hand-written apology card. Please send me an email with your address.

### Binary builds

After the package has been accepted by CRAN it will be built for each platform. It's possible this may uncover further errors.

## Prepare for next version {#post-release}

Once you've received confirmation that all checks have passed on all platforms, you have a couple of technical operations to do:

* Github release/`git tag`, so you can mark exactly what version of the code this release
  corresponds to. If you use github, use github releases - copy and paste
  the relevant portion of the NEWS file (converting to markdown if needed).

* bump version in `DESCRIPTION` and `NEWS` files. Use `.9000` prefix to 
  indicate that it's a development version.

* git commit and push

## Promotion {#promotion}

Then you need to publicise your package.  This is vitally important - for your hard work to be useful to someone, they need to know that it exists!

Start by writing a release announcement. This should be an Rmarkdown document that briefly describes what the package does (so people who haven't used it before can understand why they might care), and what's new in this version.  Start with what you've listed in `NEWS.md`, but the goal in the release announcement is not to be comprehensive, it's to highlight the most important new features.You can include a link at the end of the announcement to the full release notes so people can see all the changes. Where possible, I recommend showing examples of the new features: it's much easier to understand the benefit of a new feature if you can see it in action. 

There are a number of places you can include the announcement:

* If you have a blog, publish it there. I now publish all package release
  announcements on the [RStudio blog](http://blog.rstudio.org/author/hadleywickham/).
* If you use twitter, tweet about it.
* Send it to the r-packages mailing list.
