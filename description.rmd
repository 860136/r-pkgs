---
title: Package basics
layout: default
output: bookdown::html_chapter
---

# Package metadata {#description}

The job of the `DESCRIPTION` file is to store important metadata about your package. In the early stages of package development, the most important thing that the `DESCRIPTION` does is record which other packages your package needs. It becomes becomes increasingly important as you get closer to releasing your package to others because it also lays out who can use it (the license), and who to contact (you!) if there are any problems.

## A minimal `DESCRIPTION` file {#minimal-description}

Every package must have a `DESCRIPTION`, and in fact it's the distinguishing feature of a package - RStudio and devtools consider any directory containing a `DESCRIPTION` to be a package. To get you started, `devtools::create()` automatically adds a minimal description. This means you don't need to worry about the `DESCRIPTION` in the early stages of package development. 

The minimal description will vary a bit depending on some system settings, but will look something like this:

    Package: package-name
    Title: What the package does (short line)
    Version: 0.1
    Authors@R: "First Last <first.last@example.com> [aut, cre]"
    Description: What the package does (paragraph)
    Depends: R (>= 3.1.0)
    License: What license is it under?
    LazyData: true

The `DESCRIPTION` uses a simple file format called DCF, the Debian control format. You can see most of the structure in this simple example. Each line consists of a __field__ name and a value, separated by a colon. When values span multiple lines, they need to be indented:

    Description: The description of a package is usually long,
        spanning multiple lines. The second and subsequent lines
        should be indented, usually with four spaces.

The minimal `DESCRIPTION`, but provides the bare necessities to be valid. This is the critical subset of package metadata: what it's called (`Package`), what it does (`Title`, `Description`), what version it is (`Version`), who's allowed to use and distribute it (`License`), and who wrote it (`Author@R`).

In the rest of the chapter, you'll learn what these fields do. We'll start with package, title and description, since they're fairly next. Next you'll learn about the two most important fields. They are not included in the minimal description, but are `Imports` and `Suggests`: these are the fields that tell R that you need (for imports) or want (for suggests) additional packages to be available. You'll learn about those fields in the next section, and then we'll go on to describe the other important fields in the rest of the chapter.

## What is your package called? {#naming}

The `Package` field defines the name of the package. This should be same as the name of directory. Often the hardest thing about creating a new package is coming up with a good name. There's only one formal requirement: the package name can only consist of letters, numbers and `.`. It must start with a letter and cannot end with a period. Unfortunately this means you can't use `-` or `_` in your package name. I recommend against using `.` to in package names because the other connotations (i.e. file extension or S3 method) are confusing.

If you're planning on releasing your package to the wild, I think it's worth spending a few minutes to come up with a good name. I have two recommendations:

* Pick a unique name so you can easily google it. This makes it easy for 
  potential users to find your package, and it makes it easier for you to
  see who's using your package.

* Avoid using both upper and lower case letters: they make the package name
  hard to type and hard to remember. For example, I can never remember if it's
  `Rgtk2` or `RGTK2` or `RGtk2`.

Some strategies I've used in the past to create packages names:

* Find a name evocative of the problem and modify it so that it's unique:
  `plyr` (generalisation of apply tools), `lubridate` (makes dates and times
  easier), `mutatr` (mutable objects), `classifly` (high-dimensional views of
  classification).

* Use abbreviations: `lvplot` (letter value plots), `meifly` (models explored
  interactively).

* Add an extra R: `stringr` (string processing), `tourr` (grand tours), `httr`
  (HTTP requests).

## What does the package do? {#pkg-description}

There are two fields that describe the package. They differ in length:

* `Title` is a one line description of the package, and is often shown in 
  package listing. It should be plain text (no markup), be capitalised like a 
  sentence, but not end in a period. Keep it short: listings will often 
  truncate the title to 65 characters.

* `Description` is more detailed: you can use multiple sentences, but still 
  only one paragraph. The most common place to see the description is on the
  CRAN download page.
  
  If your description spans multiple lines (and it should!), keep each
  line at most 80 characters wide, and indent subsequent lines with 4 spaces.

The `Title` and `Description` for ggplot2 are:

```
Title: An implementation of the Grammar of Graphics
Description: An implementation of the grammar of graphics
    in R. It combines the advantages of both base and
    lattice graphics: conditioning and shared axes are
    handled automatically, and you can still build up a
    plot step by step from multiple data sources. It also
    implements a sophisticated multidimensional
    conditioning system and a consistent interface to map
    data to aesthetic attributes. See the ggplot2 website
    for more information, documentation and examples.
```

And these are rendered on the CRAN download page as follows:

```{r, echo = FALSE}
bookdown::embed_png("diagrams/cran-package.png")
```

### Exercises

* Read the title and description of the packages that you use most commonly.
  What do they do well? What could they do better?

## What does the package need? {#dependencies}

It's the job of the `DESCRIPTION` to list which other packages that your package needs to work. R has a rich set of ways of describing potential dependencies. For example, the following lines indicates that that your package needs both ggvis and dplyr to work:

    Imports:
        ggvis,
        dplyr

Whereas these lines means that your package can take advantage of ggvis and dplyr, but they're not crucial:

    Suggests:
        ggvis,
        dplyr

The two most important fields are:

*   `Imports`: your package requires these packages to work. This ensures the
    package is available, but does not automatically load all functions into your
    workspace. Instead, it's best practice to explicitly refer to external 
    functions using the syntax `package::function()`. When reading your code in
    the future, this makes it very easy to identify functions that live outside
    your package.
  
    Adding packages to `Imports` ensures that they are always available. When
    your package is installed, any packages that are listed in Imports but are
    not currently installed will be automatically installed.
  
    If you use functions from another package extensively, this can be a bit
    verbose and add unnecessary mental reading weight. There is also a 
    minor performance penalty (normally only important if you're inside a loop
    that's being called millions of times). You'll learn about alternatives in
    [namespace imports](#imports).

*   `Suggests`: you don't absolutely need these packages but they might be
    helpful. Maybe they provide datasets for examples, or only used by one
    function in your package. 
  
    Packages listed in `Suggests` are not automatically installed when your 
    package is installed. This means that you need to check if the package is
    available before calling any functions in it. Unfortunately base R does 
    not come with a function to check if a package is installed, so you'll
    need to add this simple function to your package:
  
    ```{r}
    is_installed <- function(pkg, version = 0) {
      system.file(package = pkg) != "" && packageVersion(pkg) > version
    }
    ```
    
    Then your code will look like this:
    
    ```{r}
    my_fun <- function(a, b) {
      if (!is_installed("pkg")) {
        stop("Pkg needed for this function to work. Please install it.",
          call. = FALSE)
      }
      x <- pkg::fun1(a, b)
      pkg::fun2(x, 10)
    }
    ```
    
    As we'll learn later, any package that you need for testing or vignettes
    must be listed in (at least) suggests.

The easiest way to add dependencies to your package is to use `devtools::use_package()`. This automatically adds them in the right place in your `DESCRIPTION`, and reminds you how to use them.

```{r, eval = FALSE}
devtools::use_package("Rcpp") # Defaults to imports
devtools::use_package("Rcpp", "Suggests")
```

### Versioning

It's also possible to specify version information about the required packages. You can specify a minimal required version like `MASS (>= 7.3.0)`.  You can specify exact version dependency with `MASS (= 7.3.0)`, but this is not recommended - since R can't have multiple versions of the same package loaded at the same time, specifying an exact dependency dramatically increases the chance of conflicting versions that can't be resolved.

Versioned dependences look like this:

    Imports:
        ggvis (>= 0.2),
        dplyr (>= 0.3.0.1)

Versioning is particularly important if you want to release your package. Often people will have an older version of a package loaded, and they will get an unhelpful error if you rely on new features without being explicit about the version. Generally, I think it's better to be conservation about version specifications - unless you know otherwise, add the version that you're currently using.

### Other depencies

Three others are useful in more specialised circumstances:

* `Depends`: use this if your package requires a specify version of R to work.
  As with packages, it's a good idea to play it safe and set to the version
  of R that you're currently using (which is what `devtools::create()`) does
  for you. For example, `Depends: R (>= 3.0.1)`.
  
  The only other time you need to use depends is if you're using S4.
  For various historical reasons you need to put `methods` in depends, not
  instead of imports. You'll also need to put `imports(methods)` in your
  `NAMESPACE`, as discussed in [S4 and namespaces](#namespace-s4).

  Prior to the introduction of namespaces, depends was the only way to state
  that your package needed another package. Now it's much better to use imports
  for reasons that we'll discuss in [namespaces](#namespace).
  
* `LinkingTo`: needs to link to or compile against the C code included in
  this package. This is discussed in more detail in [compiled code](#src).
  
* `Enhances`: these packages are "enhanced" by your package, typically because
  you provide methods for classes defined in the package. It's a sort of reverse
  suggests. But it's hard to define what that actually means, so I recommend 
  that you don't use it.
  
You can also list other things that your package needs outside of R in the in `SystemRequirements` field. But this is just a plain text field and is not automatically checked. Think of it as a quick reference; you'll also need to include detailed system requirements (and how to install them) in your README.

### Exercises

* What are the dependencies of ggplot2?

* What does `devtools::rev_dep()` do? Why might you use it?

## Who wrote the package? {#author}

To describe who wrote the packaage, and who to contact if something goes wrong, use the `Authors@R` field. This field is unique because it contains executable R code rather than plain text. Here's an example:

    Authors@R: person("Hadley", "Wickham", email = "hadley@rstudio.com"
      role = c("aut", "cre"))

The `person()` function has four main arguments:

* The name specified by the first two arguments,  `given` and `family` (these
  are normally supplied by position, not name). In English cultures given is 
  the first name and family is the last name, but this convention differs 
  across cultures.
  
* The `email` address.

* A three letter code specifying the `role`. There are four important roles:

    * `cre`: the package creator or maintainer, the person you should bother 
      if you have problems.
      
    * `aut`: full authors who have contributed much to the package.
    
    * `ctb`: people who have made smaller contributions, like patches.
    
    * `cph`: copyright holder. This is used if copyright is held by someone 
      other than the author, typically a company (their employer).
    
    (The [full list of roles](http://www.loc.gov/marc/relators/relaterm.html) is
    extremely comprehensive. Should your package have a woodcutter ("wdc"), 
    lyricist ("lyr") or costume designer ("cst"), rest comfortably that you can 
    correctly ascribe their role in your package.)

If you need additional clairification, you can also use the `comment` argument to supply additional arbitrary text.

You can list multiple authors with `c()`:

    Authors@R: c(
        person("Hadley", "Wickham", email = "hadley@rstudio.com", role = "cre"),
        person("Winston", "Chang", email = "winston@rstudio.com", role = "aut"))

Every package must have at least one author (aut) and one creator (cre) (they might be the same person). The creator must have an email addresses. These fields are used to generate the basic citation for a package (e.g. `citation("pkgname")`). Only people listed as authors will be included in the autogenerated citation.

There are a few extra details if you're including code that other people have written. Since this most commonly occurs when you're wrapping a C library, it's discussed in [compiled code](#src).

As well as providing your email address, it's also a good idea to list other resources avaialble for help. You can list urls in `URL` Multiple urls can be separated with a comma. `BugReports` takes a url to where bug reports should be submitted.

You can also use separate `Maintainer` and `Author` and fields to describe authors and maintainers. I prefer not to use these fields because `Authors@R` offers richer metadata. 

### On CRAN

The most important thing to note is that your email address (i.e. the address of the `cte`) is the address that CRAN will use to contact you about your package. For this reason, make sure you choose an email address that's likely to be around for a while. The CRAN policies require that this be for a single person (not a mailing list), and it can not require any confirmation or filtering to post to it, as it will be used for automated mailings.

## Who can use it? {#license}

`License`: a standard abbreviation for an open source license, like `GPL-2` or `BSD`.

The license is only really important if your planning on releasing your package. If you don't, you can ignore this section. If you want to make it clear that your package is not open source, use `License: file LICENSE` and then create a file called `LICENSE`, containing (e.g.): 

    Proprietary 

    Do not distribute outside of Widgets Incorporated.

Open source software licensing is a rich and complex field. There are many many options to choose from. I'm not a lawyer, and if you're really concerned you should consult one. Instead, I'm going to give you some fairly sweeping advice that holds for most cases. In my opinon, there are really only three licenses that you need to worry about for R packages:

*   [MIT](https://tldrlegal.com/license/gnu-general-public-license-v2) 
    (v. similar: to BSD 2 and 3 clause licenses): this is simple and
    permissive license. The only restriction is that if you distribute software
    that uses the MIT license, you must also distribute the license.
  
    The MIT license is a "template", so if you use it, you need 
    `License: MIT + file LICENSE`, and `LICENSE` file that looks like this:
  
        YEAR: 2014
        COPYRIGHT HOLDER: Hadley Wickham, RStudio

* [GPL-2](https://tldrlegal.com/license/gnu-general-public-license-v2) or 
  [GPL-3](https://tldrlegal.com/license/gnu-general-public-license-v3-(gpl-3)): 
  a "copy-left" licenses. These licenses are stricter
  and require any who distributes your code, or modified versions of you code
  (derivative works), to also make the source code avaialble. GPL-3 is a little
  stricter than GPL-2, attempting to close some loopholes.

* `CC0`: This is most appropriate for data packages. This relinquishes all your
  rights on the code and data so that it can be freely used by any one for any
  purpose (this is sometimes called putting it in the public domain, although
  that term is not well-defined, and not meaningful in all countries). 
  
  Data, at least in the US, is not copyrightable anyway, so you're not
  really giving up much. This license just makes it clear.
  
If you'd like to learn more about others, Github's [http://choosealicense.com/licenses/](choosealicense.com) is a good place to start for the most popular licenses. Another good resource is <https://tldrlegal.com/>, which explains the most important parts of each license.

If you are using a non-standard license, put `file LICENSE` and then include the full text of the license in a `LICENSE`.

If you include code written by other people, you need to make sure you're include their license details. Since this occurs most commonly when you're including C source code, it's discussed in more detail there.

### On CRAN

If you want to release your package to CRAN, you need to pick a standard license. Otherwise it's difficult for CRAN to determine whether or not it's legal for them to distribute your package!

A complete list of valid licenses for cran can be found at <https://svn.r-project.org/R/trunk/share/licenses/license.db>.

```{r, results='asis', echo = FALSE, eval = FALSE}
licenses <- read.dcf(file.path(R.home("share"), "licenses", "license.db"))
licenses <- as.data.frame(licenses, stringsAsFactors = FALSE)
licenses <- licenses[order(licenses$Name, licenses$Version), ]
licenses[is.na(licenses)] <- ""
has_abbrev <- subset(licenses, Abbrev != "")
knitr::kable(has_abbrev[c("Name", "Version", "Abbrev")], row.names = FALSE)
```

## Other components

A number of other fields are described elsewhere in the book:

* `Collate`: controls the order in which R files are source. This only
  matters if your functions have side-effects, most commonly because you're
  using S4. This is described in more depth in [collation order](#collate).

* `Version`: the version number, which should be of the the form 
  `major.minor.patchlevel`. This is most important when releasing your package. 
  See [version numbers](#version) for more deatils.

* `LazyData`. Described in [external data](#data).

There are even more fields that are rarely (if ever) used. A complete list can be found in the found in the "The DESCRIPTION file" section of the [R extensions manual][description].

You can also use your own fields to add additional arbitrary metadata. The only restriction is that you shouldn't use existing names, and if you plan to submit to CRAN the names should be valid English words (so a spell-checking NOTE isn't generated).

